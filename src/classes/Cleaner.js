const BadWords = require("bad-words");

class Cleaner {
  static BATCH_SIZE = 100;
  /**
   * Each instance handles a single clean execution.
   * cleanCalls tracks the number of recursive calls generated by the
   * request in order to determine when the cleaning is complete.
   * @param {Message} initialMessage The message where cleaning begins.
   */
  constructor(initialMessage, args) {
    this.initialMessage = initialMessage;
    this.options = { limit: Cleaner.BATCH_SIZE };
    if (args._.length == 0) this.rules = new BadWords();
    else {
      this.rules = new BadWords({ emptyList: true });
      this.rules.addWords(...args._);
    }
    this.filters = [];
    if (!args.blocks) this.filters.push(this.checkProfanityWithin.bind(null, "```", this.rules));
    //if (!args.links) this.filters.push(this.checkProfanityInLinks.bind(null, this.rules));
    if (!args.quotes) {
      this.filters.push(this.checkProfanityWithin.bind(null, '"', this.rules));
      this.filters.push(this.checkProfanityWithin.bind(null, "'", this.rules));
    }
  }

  async start() {
    var message = this.initialMessage;
    while (message) {
      this.options.before = message.id;
      let messages = await message.channel.messages.fetch(this.options);
      messages.filter(m => {
        for (let f of this.filters) {
          if (f(m.content)) return false;
        }
        return this.rules.isProfane(m.content);
      }).forEach(async m => await m.delete());
      message = messages.last();
    }
  }

  checkProfanityWithin(delim, rules, content) {
    let substrings = content.split(delim);
    if (substrings.length % 2 == 0) return false; // Ambiguous delimiting
    for (let i = 1; i < substrings.length; i+=2) {
      if (rules.isProfane(substrings[i])) return true;
    }
    return false;
  }
  /*
  checkProfanityInLinks(rules, content) {
    let re = new RegExp("[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)");
    let groups = content.match(re);
    if (groups) {
      for (let substr of groups) {
        if (rules.isProfane(substr)) return true;
      }
    }
    return false;
  }
  */
}

module.exports = Cleaner;
